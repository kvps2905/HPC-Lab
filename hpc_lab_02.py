# -*- coding: utf-8 -*-
"""HPC-Lab-02.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v2A4RgL2drOZYSyxYoRZvK7bF1BfKWZG
"""

# section_a_vector_dot.py
import time, random, cProfile, pstats, io, tracemalloc, sys

def gen_data(n, seed=42):
  random.seed(seed)
  x = [random.random() for _ in range(n)]
  y = [random.random() for _ in range(n)]
  return x, y

def vector_add(x, y):
  out = []
  for a, b in zip(x, y):
    out.append(a + b)
  return out

def dot_product(x, y):
  s = 0.0
  for a, b in zip(x, y):
    s += a * b
  return s

def main():
  # Ensure tracemalloc is stopped from any previous runs before starting new profiling
  if tracemalloc.is_tracing():
      tracemalloc.stop()

  # Explicitly ensure sys.setprofile is None before attempting to enable cProfile
  # This is the most robust way to clear any lingering profiler hooks.
  sys.setprofile(None)

  # Ensure any previous cProfile or other sys.setprofile hooks are disabled
  # by creating a temporary profiler and immediately disabling it.
  # This makes the environment clean before enabling the current profiler.
  temp_pr = cProfile.Profile()
  temp_pr.disable() # This sets sys.setprofile(None)

  N = 2_000_000 # adjust based on your machine
  x, y = gen_data(N)

  # --- CPU Profiling with cProfile ---
  pr = cProfile.Profile()
  pr.enable()

  t0 = time.perf_counter()
  s = dot_product(x, y)
  t1 = time.perf_counter()

  t2 = time.perf_counter()
  z = vector_add(x, y)
  t3 = time.perf_counter()

  pr.disable()

  # --- Memory Profiling with tracemalloc ---
  # Since cProfile is now disabled, tracemalloc can run.
  tracemalloc.start()
  # Rerun operations to capture memory usage
  _ = dot_product(x, y) # Assign to _ as result is not needed, just memory
  _ = vector_add(x, y)
  current, peak = tracemalloc.get_traced_memory()
  tracemalloc.stop()

  # Print results
  print(f"Vector length N={N}")
  print(f"Dot product: {s:.6f} | Time: {t1 - t0:.3f} s")
  print(f"Vector add: len(z)={len(z)} | Time: {t3 - t2:.3f} s")
  print(f"Current/Peak memory: {current/1e6:.2f} MB / {peak/1e6:.2f} MB")

  # Profiler output
  s_buf = io.StringIO()
  ps = pstats.Stats(pr, stream=s_buf).sort_stats('cumtime')
  ps.print_stats(15)
  print("\n--- cProfile (Top 15 by cumulative time) ---")
  print(s_buf.getvalue())

# Call main() to execute the profiling when the cell is run
  main()

main()

# section_a_vector_dot.py
import time, random, cProfile, pstats, io, tracemalloc

def gen_data(n, seed=42):
    random.seed(seed)
    x = [random.random() for _ in range(n)]
    y = [random.random() for _ in range(n)]
    return x, y

def vector_add(x, y):
    out = []
    for a, b in zip(x, y):
        out.append(a + b)
    return out

def dot_product(x, y):
    s = 0.0
    for a, b in zip(x, y):
        s += a * b
    return s

def main():
    N = 2_000_000  # adjust based on your machine
    x, y = gen_data(N)

    tracemalloc.start()
    pr = cProfile.Profile()
    pr.enable()

    t0 = time.perf_counter()
    s = dot_product(x, y)
    t1 = time.perf_counter()

    t2 = time.perf_counter()
    z = vector_add(x, y)
    t3 = time.perf_counter()

    pr.disable()
    current, peak = tracemalloc.get_traced_memory()
    tracemalloc.stop()

    # Print results
    print(f"Vector length N={N}")
    print(f"Dot product: {s:.6f} | Time: {t1 - t0:.3f} s")
    print(f"Vector add: len(z)={len(z)} | Time: {t3 - t2:.3f} s")
    print(f"Current/Peak memory: {current/1e6:.2f} MB / {peak/1e6:.2f} MB")

    # Profiler output
    s_buf = io.StringIO()
    ps = pstats.Stats(pr, stream=s_buf).sort_stats('cumtime')
    ps.print_stats(15)
    print("\n--- cProfile (Top 15 by cumulative time) ---")
    print(s_buf.getvalue())

if __name__ == "__main__":
    main()

# section_a_vector_dot.py
import time, random, cProfile, pstats, io, tracemalloc

def gen_data(n, seed=42):
    random.seed(seed)
    x = [random.random() for _ in range(n)]
    y = [random.random() for _ in range(n)]
    return x, y

def vector_add(x, y):
    out = []
    for a, b in zip(x, y):
        out.append(a + b)
    return out

def dot_product(x, y):
    s = 0.0
    for a, b in zip(x, y):
        s += a * b
    return s

def main():
    N = 2_000_000  # adjust based on your machine
    x, y = gen_data(N)

    tracemalloc.start()
    pr = cProfile.Profile()
    pr.enable()

    t0 = time.perf_counter()
    s = dot_product(x, y)
    t1 = time.perf_counter()

    t2 = time.perf_counter()
    z = vector_add(x, y)
    t3 = time.perf_counter()

    pr.disable()
    current, peak = tracemalloc.get_traced_memory()
    tracemalloc.stop()

    # Print results
    print(f"Vector length N={N}")
    print(f"Dot product: {s:.6f} | Time: {t1 - t0:.3f} s")
    print(f"Vector add: len(z)={len(z)} | Time: {t3 - t2:.3f} s")
    print(f"Current/Peak memory: {current/1e6:.2f} MB / {peak/1e6:.2f} MB")

    # Profiler output
    s_buf = io.StringIO()
    ps = pstats.Stats(pr, stream=s_buf).sort_stats('cumtime')
    ps.print_stats(15)
    print("\n--- cProfile (Top 15 by cumulative time) ---")
    print(s_buf.getvalue())

if __name__ == "__main__":
    main()

# section_b_matmul.py
import time, random, cProfile, pstats, io, tracemalloc

def gen_matrix(n, seed=123):
    random.seed(seed)
    return [[random.random() for _ in range(n)] for _ in range(n)]

def matmul_naive(A, B):
    n = len(A)
    C = [[0.0]*n for _ in range(n)]
    for i in range(n):
        for k in range(n):
            aik = A[i][k]
            for j in range(n):
                C[i][j] += aik * B[k][j]
    return C

def main():
    n = 150  # raise/lower based on your machine; O(n^3)
    A = gen_matrix(n, seed=1)
    B = gen_matrix(n, seed=2)

    tracemalloc.start()
    pr = cProfile.Profile()
    pr.enable()

    t0 = time.perf_counter()
    C = matmul_naive(A, B)
    t1 = time.perf_counter()

    pr.disable()
    current, peak = tracemalloc.get_traced_memory()
    tracemalloc.stop()

    print(f"Matrix size n={n} -> {n}x{n}")
    print(f"Time: {t1 - t0:.3f} s | C[0][0]={C[0][0]:.6f}")
    print(f"Current/Peak memory: {current/1e6:.2f} MB / {peak/1e6:.2f} MB")

    s_buf = io.StringIO()
    ps = pstats.Stats(pr, stream=s_buf).sort_stats('cumtime')
    ps.print_stats(10)
    print("\n--- cProfile (Top 10 by cumulative time) ---")
    print(s_buf.getvalue())

if __name__ == "__main__":
    main()

# section_c_conv2d.py
import time, cProfile, pstats, io, tracemalloc

def gen_grid(h, w):
    return [[(i*j) % 255 / 255.0 for j in range(w)] for i in range(h)]

def conv2d(grid, kernel):
    H, W = len(grid), len(grid[0])
    kh, kw = len(kernel), len(kernel[0])
    rh, rw = kh//2, kw//2
    out = [[0.0]*W for _ in range(H)]
    for i in range(rh, H-rh):
        for j in range(rw, W-rw):
            acc = 0.0
            for di in range(-rh, rh+1):
                for dj in range(-rw, rw+1):
                    acc += grid[i+di][j+dj] * kernel[di+rh][dj+rw]
            out[i][j] = acc
    return out

def make_uniform_kernel(size=5):
    val = 1.0 / (size*size)
    return [[val]*size for _ in range(size)]

def main():
    H, W = 256, 256  # adjust based on machine
    grid = gen_grid(H, W)
    kernel = make_uniform_kernel(5)

    tracemalloc.start()
    pr = cProfile.Profile()
    pr.enable()

    t0 = time.perf_counter()
    out = conv2d(grid, kernel)
    t1 = time.perf_counter()

    pr.disable()
    current, peak = tracemalloc.get_traced_memory()
    tracemalloc.stop()

    print(f"Grid: {H}x{W} | Kernel: 5x5 | Time: {t1 - t0:.3f} s")
    print(f"Sample out[128][128]={out[128][128]:.6f}")
    print(f"Current/Peak memory: {current/1e6:.2f} MB / {peak/1e6:.2f} MB")

    s_buf = io.StringIO()
    ps = pstats.Stats(pr, stream=s_buf).sort_stats('cumtime')
    ps.print_stats(10)
    print("\n--- cProfile (Top 10 by cumulative time) ---")
    print(s_buf.getvalue())

if __name__ == "__main__":
    main()

# section_d_montecarlo_pi.py
import time, random, cProfile, pstats, io, tracemalloc

def estimate_pi(n_samples, seed=2025):
    random.seed(seed)
    inside = 0
    for _ in range(n_samples):
        x = random.random()
        y = random.random()
        if x*x + y*y <= 1.0:
            inside += 1
    return 4.0 * inside / n_samples

def main():
    N = 2_000_000  # adjust for your machine
    tracemalloc.start()
    pr = cProfile.Profile()
    pr.enable()

    t0 = time.perf_counter()
    pi_est = estimate_pi(N)
    t1 = time.perf_counter()

    pr.disable()
    current, peak = tracemalloc.get_traced_memory()
    tracemalloc.stop()

    print(f"N={N} -> pi â‰ˆ {pi_est:.6f} | Time: {t1 - t0:.3f} s")
    print(f"Current/Peak memory: {current/1e6:.2f} MB / {peak/1e6:.2f} MB")

    s_buf = io.StringIO()
    ps = pstats.Stats(pr, stream=s_buf).sort_stats('cumtime')
    ps.print_stats(10)
    print("\n--- cProfile (Top 10 by cumulative time) ---")
    print(s_buf.getvalue())

if __name__ == "__main__":
    main()

# section_e_pairwise.py
import time, random, math, cProfile, pstats, io, tracemalloc

def gen_points(n, seed=7):
    random.seed(seed)
    return [(random.random(), random.random()) for _ in range(n)]

def pairwise_potential(points, eps=1e-6):
    n = len(points)
    pot = [0.0]*n
    for i in range(n):
        xi, yi = points[i]
        acc = 0.0
        for j in range(n):
            if i == j:
                continue
            xj, yj = points[j]
            dx, dy = xi - xj, yi - yj
            r = math.sqrt(dx*dx + dy*dy) + eps
            acc += 1.0 / r
        pot[i] = acc
    return pot

def main():
    N = 800  # adjust based on machine; O(N^2) interactions
    pts = gen_points(N)

    tracemalloc.start()
    pr = cProfile.Profile()
    pr.enable()

    t0 = time.perf_counter()
    pot = pairwise_potential(pts)
    t1 = time.perf_counter()

    pr.disable()
    current, peak = tracemalloc.get_traced_memory()
    tracemalloc.stop()

    print(f"N={N} -> computed potentials | Time: {t1 - t0:.3f} s")
    print(f"Sample pot[0]={pot[0]:.6f}, pot[N//2]={pot[N//2]:.6f}")
    print(f"Current/Peak memory: {current/1e6:.2f} MB / {peak/1e6:.2f} MB")

    s_buf = io.StringIO()
    ps = pstats.Stats(pr, stream=s_buf).sort_stats('cumtime')
    ps.print_stats(10)
    print("\n--- cProfile (Top 10 by cumulative time) ---")
    print(s_buf.getvalue())

if __name__ == "__main__":
    main()